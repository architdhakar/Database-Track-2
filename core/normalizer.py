"""
Takes the raw json data from the api and cleans it.
"""
import re
from datetime import datetime

class Normalizer:
    def __init__(self):
        # Map of "Bad Key" -> "Good Key"
        
        self.synonym_map = {
            "ip": "ip_address",
            "IP": "ip_address",
            "IpAddress": "ip_address",
            "ipAddress": "ip_address",
            "user": "user_name",         
            "userName": "user_name",
            "User_Name": "user_name",
            "t_stamp": "t_stamp",        
            "timestamp": "t_stamp"      
        }

    def _to_snake_case(self, key):
        """
        Converts CamelCase or random casing to snake_case.
        """
        # Insert underscore before capital letters (except the first one)
        s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', key)
        # Handle cases like 'IPAddress' -> 'ip_address'
        s2 = re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1)
        return s2.lower()

    def normalize_record(self, record):
        """
        Takes a single raw JSON record and returns a normalized dictionary.
        """
        normalized_record = {}

        # 1. Generate Server Timestamp (sys_ingested_at)
        #  Must be autogenerated on server side upon receipt.
        # We add it here to ensure every record leaving the normalizer has it.
        if 'sys_ingested_at' not in record:
            normalized_record['sys_ingested_at'] = datetime.now().isoformat()
        else:
            normalized_record['sys_ingested_at'] = record['sys_ingested_at']

        for key, value in record.items():
            # Skip if we already handled sys_ingested_at
            if key == 'sys_ingested_at':
                continue
            
            # 2. Check Synonym Map (Hard resolution)
            # This handles specific assignment requirements like "ip vs IP" [cite: 25, 39]
            if key in self.synonym_map:
                standard_key = self.synonym_map[key]
            else:
                # 3. Fallback to Snake Case (Soft resolution)
                # Handles generic "userName" -> "user_name"
                standard_key = self._to_snake_case(key)
            normalized_record[standard_key] = value

        return normalized_record

    def normalize_batch(self, batch):
        return [self.normalize_record(rec) for rec in batch]


if __name__ == "__main__":
    test_batch = [
        {"userName": "alice", "IP": "192.168.1.1", "t_stamp": "2026-01-28 10:00:00"},
        {"User_Name": "bob", "ip": "192.168.1.2", "timestamp": "2026-01-28 10:05:00"},
        {"deviceID": 101, "Status": "Active"}
    ]
    
    norm = Normalizer()
    clean_batch = norm.normalize_batch(test_batch)
    
    import json
    print(json.dumps(clean_batch, indent=2))
